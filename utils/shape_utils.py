import numpy as np
import struct

def voxel_to_obj(vertices, faces):
    """Convert mesh data to OBJ format string"""
    obj_lines = []
    obj_lines.append("# Generated by 3D Generative Design System")
    obj_lines.append("# Format: OBJ")
    obj_lines.append("")

    # Write vertices
    for v in vertices:
        obj_lines.append(f"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}")

    obj_lines.append("")

    # Write faces (OBJ uses 1-based indexing)
    for f in faces:
        obj_lines.append(f"f {f[0]+1} {f[1]+1} {f[2]+1}")

    return "\n".join(obj_lines)


def voxel_to_stl(vertices, faces):
    """Convert mesh data to binary STL format"""
    # STL binary format
    num_triangles = len(faces)

    # Header (80 bytes)
    header = b"Binary STL created by 3D Generative Design System" + b" " * 30

    # Number of triangles (4 bytes)
    num_triangles_bytes = struct.pack('<I', num_triangles)

    stl_data = header + num_triangles_bytes

    # Each triangle (50 bytes)
    for face in faces:
        v1 = vertices[face[0]]
        v2 = vertices[face[1]]
        v3 = vertices[face[2]]

        # Calculate normal
        edge1 = v2 - v1
        edge2 = v3 - v1
        normal = np.cross(edge1, edge2)
        normal_length = np.linalg.norm(normal)
        if normal_length > 0:
            normal = normal / normal_length
        else:
            normal = np.array([0, 0, 1])

        # Pack triangle data
        triangle_data = struct.pack('<fff', *normal)  # Normal (12 bytes)
        triangle_data += struct.pack('<fff', *v1)     # Vertex 1 (12 bytes)
        triangle_data += struct.pack('<fff', *v2)     # Vertex 2 (12 bytes)
        triangle_data += struct.pack('<fff', *v3)     # Vertex 3 (12 bytes)
        triangle_data += struct.pack('<H', 0)         # Attribute byte count (2 bytes)

        stl_data += triangle_data

    return stl_data


def normalize_vertices(vertices, target_size=1.0):
    """Normalize vertices to fit within target size"""
    if len(vertices) == 0:
        return vertices

    min_coords = vertices.min(axis=0)
    max_coords = vertices.max(axis=0)
    size = max_coords - min_coords

    # Avoid division by zero
    size = np.maximum(size, 1e-8)

    # Center and scale
    centered = vertices - min_coords - size / 2
    scale = target_size / size.max()
    normalized = centered * scale

    return normalized


def smooth_voxel_surface(voxel_grid, iterations=1):
    """Apply simple smoothing to voxel surface"""
    from scipy.ndimage import binary_dilation, binary_erosion

    result = voxel_grid.copy()
    for _ in range(iterations):
        result = binary_dilation(result)
        result = binary_erosion(result)

    return result


def create_sample_shape(shape_type='cube', resolution=32):
    """Create sample shapes for testing"""
    voxel_grid = np.zeros((resolution, resolution, resolution), dtype=bool)
    center = resolution // 2

    if shape_type == 'cube':
        start = resolution // 4
        end = 3 * resolution // 4
        voxel_grid[start:end, start:end, start:end] = True

    elif shape_type == 'sphere':
        radius = resolution // 4
        for i in range(resolution):
            for j in range(resolution):
                for k in range(resolution):
                    dist = np.sqrt((i - center)**2 + (j - center)**2 + (k - center)**2)
                    if dist <= radius:
                        voxel_grid[i, j, k] = True

    elif shape_type == 'pyramid':
        for i in range(resolution):
            size = int((resolution - i) * 0.8)
            if size > 0:
                start = (resolution - size) // 2
                end = start + size
                voxel_grid[i, start:end, start:end] = True

    elif shape_type == 'chair':
        # Seat
        voxel_grid[12:16, 8:24, 8:24] = True
        # Back
        voxel_grid[16:28, 8:12, 8:24] = True
        # Legs
        voxel_grid[0:12, 8:12, 8:12] = True
        voxel_grid[0:12, 8:12, 20:24] = True
        voxel_grid[0:12, 20:24, 8:12] = True
        voxel_grid[0:12, 20:24, 20:24] = True

    elif shape_type == 'table':
        # Table top
        voxel_grid[20:24, 6:26, 6:26] = True
        # Legs
        voxel_grid[0:20, 6:10, 6:10] = True
        voxel_grid[0:20, 6:10, 22:26] = True
        voxel_grid[0:20, 22:26, 6:10] = True
        voxel_grid[0:20, 22:26, 22:26] = True

    elif shape_type == 'bottle':
        # Base
        for i in range(0, 8):
            r = 6 + i // 2
            voxel_grid[i, center-r:center+r, center-r:center+r] = True
        # Body
        for i in range(8, 20):
            r = 5
            voxel_grid[i, center-r:center+r, center-r:center+r] = True
        # Neck
        for i in range(20, 28):
            r = 3
            voxel_grid[i, center-r:center+r, center-r:center+r] = True

    elif shape_type == 'mug':
        # Body (hollow cylinder)
        for i in range(4, 16):
            for j in range(resolution):
                for k in range(resolution):
                    dist = np.sqrt((j - center)**2 + (k - center)**2)
                    if 4 <= dist <= 8:
                        voxel_grid[i, j, k] = True
        # Bottom
        for j in range(resolution):
            for k in range(resolution):
                dist = np.sqrt((j - center)**2 + (k - center)**2)
                if dist <= 8:
                    voxel_grid[4, j, k] = True
        # Handle
        voxel_grid[8:14, 20:24, center-2:center+2] = True

    elif shape_type == 'bed':
        # Mattress
        voxel_grid[8:12, 4:28, 6:26] = True
        # Headboard
        voxel_grid[8:20, 4:8, 6:26] = True
        # Legs
        voxel_grid[0:8, 4:8, 6:10] = True
        voxel_grid[0:8, 4:8, 22:26] = True
        voxel_grid[0:8, 24:28, 6:10] = True
        voxel_grid[0:8, 24:28, 22:26] = True

    elif shape_type == 'sofa':
        # Seat
        voxel_grid[10:14, 6:26, 10:26] = True
        # Back
        voxel_grid[14:24, 6:10, 10:26] = True
        # Arms
        voxel_grid[10:24, 6:26, 10:14] = True
        voxel_grid[10:24, 6:26, 22:26] = True

    return voxel_grid
